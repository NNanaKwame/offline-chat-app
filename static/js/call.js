/**
 * call.js
 * * This script handles all the client-side logic for the video call page.
 * It establishes a Socket.IO connection, manages user lists, and handles
 * WebRTC signaling for video calls.
 */

document.addEventListener('DOMContentLoaded', () => {
    // --- DOM Element References ---
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const userListElement = document.getElementById('user-list');
    const hangUpBtn = document.getElementById('hangUpBtn');
    const muteBtn = document.getElementById('muteBtn');
    const videoBtn = document.getElementById('videoBtn');
    const callPlaceholder = document.getElementById('call-placeholder');

    // Modal elements
    const incomingCallModal = new bootstrap.Modal(document.getElementById('incomingCallModal'));
    const callerUsernameElement = document.getElementById('callerUsername');
    const acceptCallBtn = document.getElementById('acceptCallBtn');
    const rejectCallBtn = document.getElementById('rejectCallBtn');

    // --- State Management ---
    let localStream;
    let peerConnection;
    let mySid;
    let currentCallPartner = null;
    let callerId = null; // Store the SID of the user who is calling us

    // --- Socket.IO Connection ---
    // This connects to the Socket.IO server defined in your `main.py`.
    const socket = io();

    // Configuration for the RTCPeerConnection.
    // An ICE server is required for NAT traversal. We'll use a public Google STUN server.
    const configuration = {
        iceServers: [{
            urls: 'stun:stun.l.google.com:19302'
        }]
    };

    /**
     * Initializes the local media stream (camera and microphone).
     */
    async function initLocalMedia() {
        try {
            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            localVideo.srcObject = localStream;
            // Enable call controls once media is acquired
            muteBtn.disabled = false;
            videoBtn.disabled = false;
        } catch (error) {
            console.error("Error accessing media devices.", error);
            alert("Could not access your camera and microphone. Please check permissions.");
        }
    }

    /**
     * Updates the user list displayed on the page.
     * @param {Array} users - An array of user objects from the server.
     */
    function updateUserList(users) {
        userListElement.innerHTML = ''; // Clear existing list
        users.forEach(user => {
            // Don't show the current user in the list
            if (user.id === mySid) return;

            const userElement = document.createElement('a');
            userElement.href = '#';
            userElement.className = 'list-group-item list-group-item-action d-flex justify-content-between align-items-center';
            userElement.dataset.userId = user.id;

            // User info: name and status
            const userInfo = document.createElement('div');
            const username = document.createElement('span');
            username.textContent = user.username;
            const status = document.createElement('small');
            status.className = `text-muted ms-2 status-${user.status}`;
            status.textContent = `(${user.status})`;

            userInfo.appendChild(username);
            userInfo.appendChild(status);

            // Call button
            const callBtn = document.createElement('button');
            callBtn.className = 'btn btn-sm btn-success';
            callBtn.innerHTML = '<i class="fas fa-phone"></i>';
            callBtn.disabled = user.status !== 'online'; // Disable if user is not available
            
            // --- INTEGRATION POINT: Initiating a call ---
            // This emits the 'call_request' event to the server.
            callBtn.onclick = () => {
                if (!localStream) {
                    alert("Your camera is not ready yet. Please wait a moment.");
                    return;
                }
                startCall(user.id);
            };

            userElement.appendChild(userInfo);
            userElement.appendChild(callBtn);
            userListElement.appendChild(userElement);
        });
    }

    /**
     * Creates and configures the RTCPeerConnection object.
     * @param {string} partnerSid - The SID of the call partner.
     */
    function createPeerConnection(partnerSid) {
        peerConnection = new RTCPeerConnection(configuration);

        // Add local stream tracks to the connection
        localStream.getTracks().forEach(track => {
            peerConnection.addTrack(track, localStream);
        });

        // --- INTEGRATION POINT: WebRTC ICE Candidate Handling ---
        // Fired when a new ICE candidate is generated by the local peer.
        peerConnection.onicecandidate = event => {
            if (event.candidate) {
                // Send the candidate to the other peer via the server.
                socket.emit('webrtc_ice_candidate', event.candidate);
            }
        };

        // Fired when a remote stream is added.
        peerConnection.ontrack = event => {
            remoteVideo.srcObject = event.streams[0];
            callPlaceholder.style.display = 'none';
            remoteVideo.style.display = 'block';
        };

        // Update UI for an active call
        hangUpBtn.disabled = false;
        currentCallPartner = partnerSid;
    }

    /**
     * Starts a new call to the target user.
     * @param {string} targetUserId - The SID of the user to call.
     */
    function startCall(targetUserId) {
        console.log(`Attempting to call user: ${targetUserId}`);
        currentCallPartner = targetUserId;
        socket.emit('call_request', { target_user_id: targetUserId });
    }

    /**
     * Resets the call state and cleans up resources.
     */
    function resetCallState() {
        if (peerConnection) {
            peerConnection.close();
            peerConnection = null;
        }
        remoteVideo.srcObject = null;
        remoteVideo.style.display = 'none';
        callPlaceholder.style.display = 'block';
        hangUpBtn.disabled = true;
        currentCallPartner = null;
        callerId = null;
    }

    // --- Socket.IO Event Handlers ---
    
    // Fired upon successful connection to the server.
    socket.on('connect', () => {
        mySid = socket.id;
        console.log(`Connected to server with SID: ${mySid}`);
        initLocalMedia(); // Initialize camera/mic after connecting
    });

    // --- INTEGRATION POINT: Receiving User List ---
    // Listens for 'user_list' event from the server.
    socket.on('user_list', updateUserList);

    // --- INTEGRATION POINT: Receiving an Incoming Call ---
    // Listens for 'incoming_call' from the server.
    socket.on('incoming_call', (data) => {
        // Don't show modal if already in a call
        if (currentCallPartner) return;

        callerId = data.caller_id;
        callerUsernameElement.textContent = data.caller_username;
        incomingCallModal.show();
    });

    // --- INTEGRATION POINT: Call Accepted by Responder ---
    // Listens for 'call_accepted' from the server. This is received by the caller.
    socket.on('call_accepted', async (data) => {
        console.log("Call accepted by:", data.responder_id);
        createPeerConnection(data.responder_id);
        
        // Caller creates the offer
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        
        // --- INTEGRATION POINT: Sending WebRTC Offer ---
        socket.emit('webrtc_offer', offer);
    });

    // --- INTEGRATION POINT: Handling Call Rejection/Error ---
    socket.on('call_response', (data) => {
        if (!data.accepted) {
            alert(`Call rejected by user.`);
            resetCallState();
        }
    });

    socket.on('call_error', (data) => {
        alert(`Call Error: ${data.message}`);
        resetCallState();
    });

    // --- INTEGRATION POINT: Receiving WebRTC Offer ---
    // Listens for 'webrtc_offer' from the server. This is received by the responder.
    socket.on('webrtc_offer', async (data) => {
        if (!peerConnection) {
            createPeerConnection(data.from);
        }

        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);

        // --- INTEGRATION POINT: Sending WebRTC Answer ---
        socket.emit('webrtc_answer', answer);
    });

    // --- INTEGRATION POINT: Receiving WebRTC Answer ---
    // Listens for 'webrtc_answer' from the server. This is received by the caller.
    socket.on('webrtc_answer', async (data) => {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
    });

    // --- INTEGRATION POINT: Receiving ICE Candidates ---
    // Listens for 'webrtc_ice_candidate' from the server.
    socket.on('webrtc_ice_candidate', async (data) => {
        if (peerConnection) {
            try {
                await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
            } catch (error) {
                console.error("Error adding received ICE candidate", error);
            }
        }
    });

    // --- INTEGRATION POINT: Call Ended by Partner ---
    // Listens for 'call_ended' from the server.
    socket.on('call_ended', (data) => {
        alert(`Call ended: ${data.reason}`);
        resetCallState();
    });

    // --- UI Event Listeners ---

    // Accept Call Button
    acceptCallBtn.addEventListener('click', () => {
        if (!localStream) {
            alert("Your camera and microphone are not ready.");
            return;
        }
        // --- INTEGRATION POINT: Responding to a Call ---
        socket.emit('call_response', { caller_id: callerId, accepted: true });
        incomingCallModal.hide();
        // The callee will now wait for the caller's offer.
    });

    // Reject Call Button
    rejectCallBtn.addEventListener('click', () => {
        // --- INTEGRATION POINT: Responding to a Call ---
        socket.emit('call_response', { caller_id: callerId, accepted: false });
        incomingCallModal.hide();
        resetCallState();
    });

    // Hang Up Button
    hangUpBtn.addEventListener('click', () => {
        // --- INTEGRATION POINT: Ending a Call ---
        socket.emit('end_call');
        resetCallState();
    });

    // Mute Button
    muteBtn.addEventListener('click', () => {
        const audioTrack = localStream.getAudioTracks()[0];
        audioTrack.enabled = !audioTrack.enabled;
        muteBtn.innerHTML = audioTrack.enabled ? '<i class="fas fa-microphone"></i> Mute' : '<i class="fas fa-microphone-slash"></i> Unmute';
        muteBtn.classList.toggle('btn-dark');
        muteBtn.classList.toggle('btn-warning');
    });

    // Disable Video Button
    videoBtn.addEventListener('click', () => {
        const videoTrack = localStream.getVideoTracks()[0];
        videoTrack.enabled = !videoTrack.enabled;
        videoBtn.innerHTML = videoTrack.enabled ? '<i class="fas fa-video"></i> Disable Video' : '<i class="fas fa-video-slash"></i> Enable Video';
        videoBtn.classList.toggle('btn-dark');
        videoBtn.classList.toggle('btn-warning');
    });
});